<!DOCTYPE HTML>
<html lang="en">
<head>
    <title>Friction coefficient measurement</title>
    <meta charset="utf-8">
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>

    <script src="js/three.js/build/three.min.js"></script>
    <script src="js/stats.js/build/stats.min.js"></script>
    <script src="js/three.js/examples/js/controls/OrbitControls.js"></script>
    <script src="js/three.js/examples/js/loaders/ColladaLoader.js"></script>

    <script src="js/physi.js"></script>


</head>
<body>

    <div id="container">Loading...</div>

    <script>

    // Graphics variables
    var container, stats;
    var camera, controls, scene, renderer;
    var clock = new THREE.Clock();
    var clickRequest = false;
    var mouseCoords = new THREE.Vector2();
    var raycaster = new THREE.Raycaster();
    var pos = new THREE.Vector3();
    var quat = new THREE.Quaternion();

    var colladaSceneURL = "ph-mpd-fcm.dae";
    var colladaScene;

    var physics_stats;
    var meshes = [];
    var lights = [];

    'use strict';

    Physijs.scripts.worker = "/js/physijs_worker.js";
    Physijs.scripts.ammo = "/js/ammo.js";

    init();

    var contactAudio = new Audio('sounds/contact.mp3');
    contactAudio.loop = false;
    contactAudio.autoplay = false;
    contactAudio.preload = "auto";
    var contactAudioPlayed = false;

    var contact1Audio = new Audio('sounds/contact1.mp3');
    contact1Audio.loop = false;
    contact1Audio.autoplay = false;
    contact1Audio.preload = "auto";
    var contact1AudioPlayed = false;

    var contact2Audio = new Audio('sounds/contact2.mp3');
    contact2Audio.loop = false;
    contact2Audio.autoplay = false;
    contact2Audio.preload = "auto";
    var contact2AudioPlayed = false;

    var slipAudio = new Audio('sounds/slip.mp3');
    slipAudio.loop = false;
    slipAudio.autoplay = false;
    slipAudio.preload = "auto";
    var slipAudioPlayed = false;

    var physijsReady = false;

    var textureURLs = [  // URLs of the six faces of the cube map 
            "cubemap/posx.png",   // Note:  The order in which
            "cubemap/negx.png",   //   the images are listed is
            "cubemap/posy.png",   //   important.
            "cubemap/negy.png",  
            "cubemap/posz.png",   
            "cubemap/negz.png"
       ];

    //mouse interactions
    var toIntersect = [];
    var mouseCoords = new THREE.Vector2();
    var raycaster = new THREE.Raycaster();
    var clickRequest = false;

    var slopingSurface;
    var slopingBody;
    var plumbMesh;
    var frameMesh;
    var scaleMesh;
    var framePivotMesh;
    var rope;

    var plumbLookAt = false;

    // - Functions -
    function init()
    {
        initGraphics();
        loadColladaScene();
    }

    function initGraphics()
    {
        container = document.getElementById( "container" );
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );

        scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
        scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
        scene.addEventListener(
            'update',
            function() 
            {
                physijsReady = true;
                physics_stats.update();
            }
        );

        camera.position.x = 0;
        camera.position.y = 4;
        camera.position.z = 15;

        controls = new THREE.OrbitControls(camera);
//        controls.target.y = 2;
        controls.maxPolarAngle = Math.PI/2 - 0.3; 
        controls.minDistance = 5;
        controls.maxDistance = 15;
        controls.enableKeys = false;

        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;


        container.innerHTML = "";

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        physics_stats = new Stats();
        physics_stats.domElement.style.position = 'absolute';
        physics_stats.domElement.style.top = '50px';
        physics_stats.domElement.style.zIndex = 100;
        document.getElementById( 'container' ).appendChild( physics_stats.domElement );

        window.addEventListener( 'resize', onWindowResize, false );

        requestAnimationFrame( render );
    }


    function onWindowResize()
    {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }


    var dAngle = 0.001;
    var slopingSurfaceZRot = 0.0;
    function render()
    {
        if (physijsReady)
        {
            if (Math.abs(slopingSurfaceZRot) < 0.7)
            {
                slopingSurface.rotation.set(0, 0, slopingSurfaceZRot);
                slopingSurface.__dirtyRotation = true;
                slopingSurfaceZRot -= dAngle;
                scene.simulate(undefined, 1);
                physijsReady = false;
                plumbMesh.rotation.z = -slopingSurfaceZRot;
                frameMesh.rotation.z += dAngle - 0.0002;

                //Rope
                slopingSurface.updateMatrixWorld();
                var framePivot_pos = new THREE.Vector3();
                framePivot_pos.setFromMatrixPosition(scene.getObjectByName("framePivot").matrixWorld);

                rope.geometry.vertices[0].set(framePivot_pos.x, framePivot_pos.y, framePivot_pos.z);
                rope.geometry.verticesNeedUpdate = true;

                var slopingBodyLinSpeed = slopingBody.getLinearVelocity();
//                console.log(slopingBodyLinSpeed);
                if (slopingBodyLinSpeed.x > 1)
                {
                    if (!slipAudioPlayed)
                    {
                        slipAudio.play();
                        slipAudioPlayed = true;
                    }
                }
            }

            processClick();

            if (plumbLookAt)
            {
                controls.maxPolarAngle = Math.PI/2; 
                var plumb_pos = new THREE.Vector3();
                camera.up = new THREE.Vector3(0,1,0);
                plumb_pos.setFromMatrixPosition(scene.getObjectByName("plumb").matrixWorld);
                camera.position.x = plumb_pos.x;
                camera.position.y = plumb_pos.y - 0.1;
                camera.position.z = plumb_pos.z + 1.75;
                controls.target.copy(plumb_pos);
                controls.minDistance = 1.0;
            }
        }

        var deltaTime = clock.getDelta();

        stats.update();
        controls.update(deltaTime);
        renderer.render(scene, camera);

        requestAnimationFrame( render );
    }

    function loadColladaScene()
    {
        var loader = new THREE.ColladaLoader();
        loader.options.convertUpAxis = true;
        loader.load( colladaSceneURL, traverseColladaScene );
    }

    function traverseColladaScene(collada)
    {
        colladaScene = collada.scene;
        colladaScene.traverse(function ( object ) {
            if (object instanceof THREE.Mesh)
            {
                object.name = object.parent.name;
                object.position.x = object.parent.position.x;
                object.position.y = object.parent.position.y;
                object.position.z = object.parent.position.z;

                object.rotation.x = object.parent.rotation.x;
                object.rotation.y = object.parent.rotation.y;
                object.rotation.z = object.parent.rotation.z;
                meshes.push(object);
            }
            if (object instanceof THREE.SpotLight || object instanceof THREE.PointLight)
            {
                object.name = object.parent.name;
                object.position.x = object.parent.position.x;
                object.position.y = object.parent.position.y;
                object.position.z = object.parent.position.z;
                lights.push(object);
            }
        });

        addObjects();
    }

    function addObjects()
    {
        var shape;
        var physijsMaterial;
        var physijsShapeAdded;

        for ( var i = 0, il = meshes.length; i < il; i++ )
        {

            var mesh = meshes[i];

            physijsShapeAdded = false;

            switch (mesh.name)
            {
                case "slopingSurface":
                    physijsMaterial = Physijs.createMaterial(
                        mesh.material,
                        0.5, // friction
                        0.0  // restitution
                    );
                    shape = new Physijs.ConvexMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
                    slopingSurfaceZRot = mesh.rotation.z;
/*
                    shape = new Physijs.ConcaveMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
*/
                    shape.name = mesh.name;
                    shape.mass = 0;
                    slopingSurface = shape;
                    physijsShapeAdded = true;
                break;
                case "tableTop":
                    physijsMaterial = Physijs.createMaterial(
                        mesh.material,
                        0.8, // friction
                        0.0  // restitution
                    );
                    shape = new Physijs.BoxMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
                    shape.name = mesh.name;
                    shape.mass = 0;
                    physijsShapeAdded = true;
                break;
                case "slopingSurfaceFixture":
                    physijsMaterial = Physijs.createMaterial(
                        mesh.material,
                        0.5, // friction
                        0.4  // restitution
                    );
                    shape = new Physijs.ConvexMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
                    shape.name = mesh.name;
                    shape.mass = 0;
                    physijsShapeAdded = true;
                break;
                case "slopingBody":
                    physijsMaterial = Physijs.createMaterial(
                        mesh.material,
                        0.1, // friction
                        0.5  // restitution
                    );
                    shape = new Physijs.BoxMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
                    shape.name = mesh.name;
                    shape.mass = 0.2;
                    physijsShapeAdded = true;
                    shape.addEventListener( 'collision', function(other_object, linear_velocity, angular_velocity) {
                        console.log(other_object.name);
                        if (other_object.name == 'slopingSurfaceFixture')
                        {
                            if (!contactAudioPlayed)
                            {
                                contactAudio.play();
                                contactAudioPlayed = true;
                            }
                        }
                        if (other_object.name == 'tableTop')
                        {
                            if (!contact1AudioPlayed)
                            {
                                contact1Audio.volume = 0.7;
                                contact1Audio.play();
                                contact1AudioPlayed = true;
                            }
                        }
                        if (other_object.name == 'support')
                        {
                            if (!contact2AudioPlayed)
                            {
                                contact2Audio.volume = 0.4;
                                contact2Audio.play();
                                contact2AudioPlayed = true;
                            }
                        }
                    });
                    slopingBody = shape;
                break;
                case "support":
                    physijsMaterial = Physijs.createMaterial(
                        mesh.material);
                    shape = new Physijs.ConvexMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
                    shape.name = mesh.name;
                    shape.mass = 0;
                    physijsShapeAdded = true;
                break;
                case "plumb":
                    plumbMesh = mesh;
                    plumbMesh.receiveShadow = false;
                    plumbMesh.castShadow = true;
                break;
                case "frame":
                    frameMesh = mesh;
                    frameMesh.receiveShadow = false;
                    frameMesh.castShadow = true;
                break;
                case "framePivot":
                    framePivotMesh = mesh;
                    framePivotMesh.receiveShadow = false;
                    framePivotMesh.castShadow = true;
                break;
                case "pulley":
                    mesh.receiveShadow = false;
                    mesh.castShadow = false;
                    scene.add(mesh);
                break;
                case "scale":
                    scaleMesh = mesh;
                    scaleMesh.receiveShadow = false;
                    scaleMesh.castShadow = true;
                break;
                default:
                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    scene.add(mesh);
                break;
            }

            if (physijsShapeAdded)
            {
                shape.position.x = mesh.position.x;
                shape.position.y = mesh.position.y;
                shape.position.z = mesh.position.z;

                shape.rotation.x = mesh.rotation.x;
                shape.rotation.y = mesh.rotation.y;
                shape.rotation.z = mesh.rotation.z;

                shape.receiveShadow = true;
                shape.castShadow = true;

                scene.add(shape);
            }
        }

        for ( var i = 0, il = lights.length; i < il; i++ )
        {
            var light = lights[ i ];
            light.castShadow = light.name == "Lamp";
            scene.add(light);
        }

        scene.getObjectByName("slopingSurface").add(plumbMesh);
        frameMesh.add(framePivotMesh);
        scene.getObjectByName("slopingSurface").add(frameMesh);
        scene.getObjectByName("slopingSurface").add(scaleMesh);


        //Rope
        var framePivot_pos = new THREE.Vector3();
        scene.getObjectByName("slopingSurface").updateMatrixWorld();
        framePivot_pos.setFromMatrixPosition(scene.getObjectByName("framePivot").matrixWorld);

        var frame_pos  = framePivot_pos;

        var pulley_pos = new THREE.Vector3().copy(scene.getObjectByName("pulley").position);
        pulley_pos.y += 0.25;

        var pulley_pos1 = new THREE.Vector3().copy(pulley_pos);
        pulley_pos1.x += 0.1;
        var pulley_pos2 = new THREE.Vector3().copy(pulley_pos1);
        pulley_pos2.x += 0.1;

        var pulleyMotor_pos = new THREE.Vector3().copy(scene.getObjectByName("pulleyMotor").position);
        pulleyMotor_pos.y += 0.3;
        pulleyMotor_pos.x += 0.3;

        var rope_geometry = new THREE.Geometry();
        rope_geometry.vertices.push(framePivot_pos);
        rope_geometry.vertices.push(pulley_pos);
        rope_geometry.vertices.push(pulley_pos1);
        rope_geometry.vertices.push(pulley_pos2);
        rope_geometry.vertices.push(pulleyMotor_pos);

        var material = new THREE.LineBasicMaterial({
                            color: 0x352d2a,
                            opacity: 1.0,
                            linewidth: 2
        });
        rope = new THREE.Line(rope_geometry, material);

        scene.add(rope);


        scene.simulate();

        var materials = [];
        for (var i = 0; i < 6; i++)
        {
            var tex = THREE.ImageUtils.loadTexture( textureURLs[i] );
            materials.push( new THREE.MeshBasicMaterial( {
                color: "white",
                side: THREE.BackSide,  // IMPORTANT: To see the inside of the cube, back faces must be rendered!
                map: tex
            } ) );
        }
        var envBox = new THREE.Mesh( new THREE.CubeGeometry( 150, 150, 150 ), new THREE.MeshFaceMaterial( materials ) );
        scene.add(envBox);

        // SUPER SIMPLE GLOW EFFECT
        // use sprite because it appears the same from all angles
        var spriteMaterial = new THREE.SpriteMaterial( 
        { 
            map: new THREE.ImageUtils.loadTexture( 'glow/magnifierglass.png' ), 
            useScreenCoordinates: false, color: 0xfdff45, transparent: true, blending: THREE.AdditiveBlending
        });
        var sprite = new THREE.Sprite( spriteMaterial );
        sprite.scale.set(2.0, 2.0, 2.0);
        sprite.name = "plumbInfo";
        plumbMesh.add(sprite); // this centers the glow at the mesh

        toIntersect.push(plumbMesh);
        toIntersect.push(sprite);
    }

    function onDocumentMouseMove( e )
    {
        mouseCoords.set(
        ( event.clientX / window.innerWidth ) * 2 - 1,
        - ( event.clientY / window.innerHeight ) * 2 + 1
        );

        event.preventDefault();

        raycaster.setFromCamera( mouseCoords, camera );

        var intersects = raycaster.intersectObjects( toIntersect ); 


        if ( intersects.length > 0 ) 
        {
//            if (typeof(intersects[0].object.callback) == "function")
            if (intersects[0].object.name == 'plumbInfo')
            {
                container.style.cursor = 'pointer';
            }
            else
            {
                container.style.cursor = 'auto';
            }
        }
        else
        {
            container.style.cursor = 'auto';
        }
    }

    function onDocumentMouseDown( e )
    {
        if ( ! clickRequest && e.button == 0)
        {
            mouseCoords.set(
                ( e.clientX / window.innerWidth ) * 2 - 1,
                - ( e.clientY / window.innerHeight ) * 2 + 1
            );
            clickRequest = true;
        }
    }

    function processClick() 
    {
        if ( clickRequest ) 
        {
            raycaster.setFromCamera( mouseCoords, camera );

            var intersects = raycaster.intersectObjects( toIntersect ); 
            if ( intersects.length > 0 ) 
            {
                //if (typeof(intersects[0].object.callback) == "function")
                if (intersects[0].object.name == 'plumbInfo')
                {
                    //var softVol = intersects[0].object.callback();
                    console.log("plumbInfo clicked!");
                    plumbLookAt = true;
                }
            }
            clickRequest = false;
        }
    }

    function onDocumentMouseUp(e)
    {
        if (plumbLookAt)
        {
            controls.reset();
        }
        plumbLookAt = false;
    }

    </script>
</body>
</html>

