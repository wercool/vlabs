<!DOCTYPE HTML>
<html lang="en">
<head>
    <title>Friction coefficient measurement</title>
    <meta charset="utf-8">
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>

    <script src="js/three.js/build/three.min.js"></script>
    <script src="js/stats.js/build/stats.min.js"></script>
    <script src="js/three.js/examples/js/controls/OrbitControls.js"></script>
    <script src="js/three.js/examples/js/loaders/ColladaLoader.js"></script>

    <script src="js/physi.js"></script>


</head>
<body>

    <div id="container"><br /><br /><br /><br /><br />Loading...</div>

    <script>

    // Graphics variables
    var container, stats;
    var camera, controls, scene, renderer;
    var clock = new THREE.Clock();
    var clickRequest = false;
    var mouseCoords = new THREE.Vector2();
    var raycaster = new THREE.Raycaster();
    var pos = new THREE.Vector3();
    var quat = new THREE.Quaternion();

    var colladaSceneURL = "ph-mpd-fcm.dae";
    var colladaScene;

    var physics_stats;
    var meshes = [];
    var lights = [];

    'use strict';

    Physijs.scripts.worker = "/js/physijs_worker.js";
    Physijs.scripts.ammo = "/js/ammo.js";

    init();

    var contactAudio = new Audio('sounds/contact.mp3');
    contactAudio.loop = false;
    contactAudio.autoplay = false;
    contactAudio.preload = "auto";
    var contactAudioPlayed = false;

    var slipAudio = new Audio('sounds/slip.mp3');
    slipAudio.loop = false;
    slipAudio.autoplay = false;
    slipAudio.preload = "auto";
    var slipAudioPlayed = false;

    var physijsReady = false;

    var slopingSurface;
    var slopingBody;
    var plumbMesh;
    var frameMesh;
    var framePivotMesh;
    var rope;

    // - Functions -
    function init()
    {
        initGraphics();
        loadColladaScene();
    }

    function initGraphics()
    {
        container = document.getElementById( "container" );
        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 2000 );


        scene = new Physijs.Scene({ fixedTimeStep: 1 / 100 });
        scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
        scene.addEventListener(
            'update',
            function() 
            {
                physijsReady = true;
                physics_stats.update();
            }
        );

        camera.position.x = 0;
        camera.position.y = 5;
        camera.position.z = 15;

        controls = new THREE.OrbitControls( camera );
        controls.target.y = 2;

        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;


        container.innerHTML = "";

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        physics_stats = new Stats();
        physics_stats.domElement.style.position = 'absolute';
        physics_stats.domElement.style.top = '50px';
        physics_stats.domElement.style.zIndex = 100;
        document.getElementById( 'container' ).appendChild( physics_stats.domElement );

        window.addEventListener( 'resize', onWindowResize, false );

        requestAnimationFrame( render );
    }


    function onWindowResize()
    {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }


    var dAngle = 0.001;
    var slopingSurfaceZRot = 0.0;
    function render()
    {
        if (physijsReady)
        {
            if (Math.abs(slopingSurfaceZRot) < 0.7)
            {
                slopingSurface.rotation.set(0, 0, slopingSurfaceZRot);
                slopingSurface.__dirtyRotation = true;
                slopingSurfaceZRot -= dAngle;
                scene.simulate(undefined, 1);
                physijsReady = false;
                plumbMesh.rotation.z = -slopingSurfaceZRot;
                frameMesh.rotation.z += dAngle - 0.0002;

                //Rope
                slopingSurface.updateMatrixWorld();
                var framePivot_pos = new THREE.Vector3();
                framePivot_pos.setFromMatrixPosition(scene.getObjectByName("framePivot").matrixWorld);
                var pulley_pos = new THREE.Vector3().copy(scene.getObjectByName("pulley").position);
                pulley_pos.y += 0.3;
                var rope_spline = new THREE.CatmullRomCurve3([framePivot_pos, pulley_pos]);
                var rope_geometry = new THREE.Geometry();
                rope_geometry.vertices = rope_spline.getPoints(5);
                var p;
                for ( var i = 0; i < 5; i ++ )
                {
                    p = rope.geometry.vertices[i];
                    p.copy(rope_geometry.vertices[i]);
                }
                rope.geometry.verticesNeedUpdate = true;

                var slopingBodyLinSpeed = slopingBody.getLinearVelocity();
//                console.log(slopingBodyLinSpeed);
                if (slopingBodyLinSpeed.x > 1)
                {
                    if (!slipAudioPlayed)
                    {
                        slipAudio.play();
                        slipAudioPlayed = true;
                    }
                }
            }
        }

        requestAnimationFrame( render );

        var deltaTime = clock.getDelta();

        stats.update();
        controls.update( deltaTime );
        renderer.render( scene, camera );
    }

    function loadColladaScene()
    {
        var loader = new THREE.ColladaLoader();
        loader.options.convertUpAxis = true;
        loader.load( colladaSceneURL, traverseColladaScene );
    }

    function traverseColladaScene(collada)
    {
        colladaScene = collada.scene;
        colladaScene.traverse(function ( object ) {
            if (object instanceof THREE.Mesh)
            {
                object.name = object.parent.name;
                object.position.x = object.parent.position.x;
                object.position.y = object.parent.position.y;
                object.position.z = object.parent.position.z;

                object.rotation.x = object.parent.rotation.x;
                object.rotation.y = object.parent.rotation.y;
                object.rotation.z = object.parent.rotation.z;
                meshes.push(object);
            }
            if (object instanceof THREE.SpotLight || object instanceof THREE.PointLight)
            {
                object.name = object.parent.name;
                object.position.x = object.parent.position.x;
                object.position.y = object.parent.position.y;
                object.position.z = object.parent.position.z;
                lights.push(object);
            }
        });

        addObjects();
    }

    function addObjects()
    {
        var shape;
        var physijsMaterial;
        var physijsShapeAdded;

        for ( var i = 0, il = meshes.length; i < il; i++ )
        {

            var mesh = meshes[i];

            physijsShapeAdded = false;

            switch (mesh.name)
            {
                case "slopingSurface":
                    physijsMaterial = Physijs.createMaterial(
                        mesh.material,
                        0.2, // friction
                        0.0  // restitution
                    );
                    shape = new Physijs.ConvexMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
                    slopingSurfaceZRot = mesh.rotation.z;
/*
                    shape = new Physijs.ConcaveMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
*/
                    shape.name = mesh.name;
                    shape.mass = 0;
                    slopingSurface = shape;
                    physijsShapeAdded = true;
                break;
                case "tableTop":
                    physijsMaterial = Physijs.createMaterial(
                        mesh.material,
                        0.8, // friction
                        0.0  // restitution
                    );
                    shape = new Physijs.BoxMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
                    shape.name = mesh.name;
                    shape.mass = 0;
                    physijsShapeAdded = true;
                break;
                case "slopingSurfaceFixture":
                    physijsMaterial = Physijs.createMaterial(
                        mesh.material,
                        0.8, // friction
                        0.4  // restitution
                    );
                    shape = new Physijs.ConvexMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
                    shape.name = mesh.name;
                    shape.mass = 0;
                    physijsShapeAdded = true;
                break;
                case "slopingBody":
                    physijsMaterial = Physijs.createMaterial(
                        mesh.material,
                        0.2, // friction
                        0.5  // restitution
                    );
                    shape = new Physijs.BoxMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
                    shape.name = mesh.name;
                    shape.mass = 0.15;
                    physijsShapeAdded = true;
                    shape.addEventListener( 'collision', function(other_object, linear_velocity, angular_velocity) {
                        console.log(other_object.name);
                        if (other_object.name == 'slopingSurfaceFixture')
                        {
                            if (!contactAudioPlayed)
                            {
                                contactAudio.play();
                                contactAudioPlayed = true;
                            }
                        }
                    });
                    slopingBody = shape;
                break;
                case "support":
                    physijsMaterial = Physijs.createMaterial(
                        mesh.material);
                    shape = new Physijs.ConvexMesh(
                        mesh.geometry,
                        physijsMaterial
                    );
                    shape.name = mesh.name;
                    shape.mass = 0;
                    physijsShapeAdded = true;
                break;
                case "plumb":
                    plumbMesh = mesh;
                    plumbMesh.receiveShadow = false;
                    plumbMesh.castShadow = true;
                break;
                case "frame":
                    frameMesh = mesh;
                    frameMesh.receiveShadow = false;
                    frameMesh.castShadow = true;
                break;
                case "framePivot":
                    framePivotMesh = mesh;
                    framePivotMesh.receiveShadow = false;
                    framePivotMesh.castShadow = true;
                break;
                case "pulley":
                    mesh.receiveShadow = false;
                    mesh.castShadow = false;
                    scene.add(mesh);
                break;
                default:
                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    scene.add(mesh);
                break;
            }

            if (physijsShapeAdded)
            {
                shape.position.x = mesh.position.x;
                shape.position.y = mesh.position.y;
                shape.position.z = mesh.position.z;

                shape.rotation.x = mesh.rotation.x;
                shape.rotation.y = mesh.rotation.y;
                shape.rotation.z = mesh.rotation.z;

                shape.receiveShadow = true;
                shape.castShadow = true;

                scene.add(shape);
            }
        }

        for ( var i = 0, il = lights.length; i < il; i++ )
        {
            var light = lights[ i ];
            light.castShadow = true;
            scene.add( light );
        }

        scene.getObjectByName("slopingSurface").add(plumbMesh);
        frameMesh.add(framePivotMesh);
        scene.getObjectByName("slopingSurface").add(frameMesh);


        //Rope
        var framePivot_pos = new THREE.Vector3();
        scene.getObjectByName("slopingSurface").updateMatrixWorld();
        framePivot_pos.setFromMatrixPosition(scene.getObjectByName("framePivot").matrixWorld);

        var frame_pos  = framePivot_pos;
        var pulley_pos = new THREE.Vector3().copy(scene.getObjectByName("pulley").position);
        pulley_pos.y += 0.3;

        var rope_spline = new THREE.CatmullRomCurve3([frame_pos, pulley_pos]);
        var rope_geometry = new THREE.Geometry();
        rope_geometry.vertices = rope_spline.getPoints(5);
        rope_spline.type = 'chordal';
        rope_spline.mesh = new THREE.Line(rope_geometry.clone(), new THREE.LineBasicMaterial( {
                            color: 0x352d2d,
                            opacity: 1.0,
                            linewidth: 2
                            } ) );
        rope_spline.mesh.castShadow = true;
        rope = rope_spline.mesh;
        scene.add(rope);


        scene.simulate();
    }
    </script>
</body>
</html>

